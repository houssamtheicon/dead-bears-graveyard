import React, { useState, useEffect } from 'react';
import './Gallery.css';

// Configuration
const CONFIG = {
  METADATA_BASE_URL: 'https://gateway.pinata.cloud/ipfs/bafybeifspz7rgzbrwvuoqsa5jepafex5p5x7lt4uyn2kfbkigptg4ebqgy/',
  IMAGE_BASE_URL: 'https://gateway.pinata.cloud/ipfs/bafybeih7353uke62onbpb2mac4fvko4iipd6puelmzk7etzamkbx3yzavq/',
  TOTAL_SUPPLY: 2222,
  ONE_OF_ONES: [0, 1, 2, 3, 4, 5, 6, 7] // UPDATE WITH YOUR ACTUAL 1/1 IDs
};

interface NFTAttribute {
  trait_type: string;
  value: string;
}

interface NFT {
  name: string;
  description: string;
  image: string;
  edition: number;
  attributes: NFTAttribute[];
  isOneOfOne: boolean;
}

interface Filters {
  searchId: string;
  oneOfOne: boolean;
  traits: { [key: string]: string };
  sort: string;
}

const Gallery: React.FC = () => {
  const [allNFTs, setAllNFTs] = useState<NFT[]>([]);
  const [filteredNFTs, setFilteredNFTs] = useState<NFT[]>([]);
  const [traitCategories, setTraitCategories] = useState<{ [key: string]: Set<string> }>({});
  const [loading, setLoading] = useState(true);
  const [filters, setFilters] = useState<Filters>({
    searchId: '',
    oneOfOne: false,
    traits: {},
    sort: 'id-asc'
  });

  // Load all NFTs on mount
  useEffect(() => {
    loadAllNFTs();
  }, []);

  // Apply filters when they change
  useEffect(() => {
    applyFilters();
  }, [filters, allNFTs]);

  const loadAllNFTs = async () => {
    setLoading(true);
    const loadedNFTs: NFT[] = [];
    const categories: { [key: string]: Set<string> } = {};

    // Load in batches for better performance
    const batchSize = 50;
    const batches = Math.ceil(CONFIG.TOTAL_SUPPLY / batchSize);

    for (let b = 0; b < batches; b++) {
      const promises: Promise<NFT | null>[] = [];
      const start = b * batchSize;
      const end = Math.min(start + batchSize, CONFIG.TOTAL_SUPPLY);

      for (let i = start; i < end; i++) {
        promises.push(loadNFTMetadata(i));
      }

      const results = await Promise.allSettled(promises);
      results.forEach((result) => {
        if (result.status === 'fulfilled' && result.value) {
          loadedNFTs.push(result.value);
          extractTraits(result.value, categories);
        }
      });
    }

    loadedNFTs.sort((a, b) => a.edition - b.edition);
    setAllNFTs(loadedNFTs);
    setTraitCategories(categories);
    setLoading(false);
  };

  const loadNFTMetadata = async (id: number): Promise<NFT | null> => {
    try {
      const response = await fetch(`${CONFIG.METADATA_BASE_URL}${id}.json`);
      if (!response.ok) return null;

      const metadata = await response.json();
      return {
        ...metadata,
        edition: id,
        isOneOfOne: CONFIG.ONE_OF_ONES.includes(id)
      };
    } catch (error) {
      console.warn(`Failed to load NFT #${id}`);
      return null;
    }
  };

  const extractTraits = (nft: NFT, categories: { [key: string]: Set<string> }) => {
    if (!nft.attributes) return;

    nft.attributes.forEach((attr) => {
      if (!categories[attr.trait_type]) {
        categories[attr.trait_type] = new Set();
      }
      categories[attr.trait_type].add(attr.value);
    });
  };

  const applyFilters = () => {
    let filtered = allNFTs.filter((nft) => {
      // Search by ID
      if (filters.searchId && !nft.edition.toString().includes(filters.searchId)) {
        return false;
      }

      // 1/1 filter
      if (filters.oneOfOne && !nft.isOneOfOne) {
        return false;
      }

      // Trait filters
      for (const [traitType, traitValue] of Object.entries(filters.traits)) {
        if (!traitValue) continue;

        const nftTrait = nft.attributes?.find((attr) => attr.trait_type === traitType);
        if (!nftTrait || nftTrait.value !== traitValue) {
          return false;
        }
      }

      return true;
    });

    // Apply sorting
    switch (filters.sort) {
      case 'id-asc':
        filtered.sort((a, b) => a.edition - b.edition);
        break;
      case 'id-desc':
        filtered.sort((a, b) => b.edition - a.edition);
        break;
      case 'random':
        filtered.sort(() => Math.random() - 0.5);
        break;
    }

    setFilteredNFTs(filtered);
  };

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFilters({ ...filters, searchId: e.target.value.replace(/[^0-9]/g, '') });
  };

  const toggleOneOfOne = () => {
    setFilters({ ...filters, oneOfOne: !filters.oneOfOne });
  };

  const handleSortChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setFilters({ ...filters, sort: e.target.value });
  };

  const handleTraitChange = (traitType: string, value: string) => {
    setFilters({
      ...filters,
      traits: { ...filters.traits, [traitType]: value }
    });
  };

  const clearFilters = () => {
    setFilters({
      searchId: '',
      oneOfOne: false,
      traits: {},
      sort: 'id-asc'
    });
  };

  if (loading) {
    return (
      <div className="gallery-container">
        <div className="loading">
          <div className="spinner"></div>
          <div>Loading Dead Bears from the graveyard...</div>
          <div className="progress">{allNFTs.length}/{CONFIG.TOTAL_SUPPLY}</div>
        </div>
      </div>
    );
  }

  return (
    <div className="gallery-container">
      {/* Header */}
      <div className="gallery-header">
        <h1>ðŸª¦ Dead Bears Gallery ðŸª¦</h1>
        <p>Explore 2,222 undead bears rotting on Solana</p>
      </div>

      {/* Controls */}
      <div className="controls-section">
        <div className="controls-row">
          <div className="search-box">
            <input
              type="text"
              value={filters.searchId}
              onChange={handleSearchChange}
              placeholder="Search by ID (e.g., 42, #100, Dead Bears #500)"
            />
          </div>
          <button
            className={`filter-toggle ${filters.oneOfOne ? 'active' : ''}`}
            onClick={toggleOneOfOne}
          >
            {filters.oneOfOne ? 'âœ… Showing 1/1s Only' : 'ðŸ”¥ Show 1/1s Only'}
          </button>
          <select className="sort-select" value={filters.sort} onChange={handleSortChange}>
            <option value="id-asc">ID: Low to High</option>
            <option value="id-desc">ID: High to Low</option>
            <option value="random">Random</option>
          </select>
        </div>

        {/* Trait Filters */}
        <div className="trait-filters">
          {Object.keys(traitCategories)
            .sort()
            .map((traitType) => (
              <div key={traitType} className="trait-filter">
                <select
                  value={filters.traits[traitType] || ''}
                  onChange={(e) => handleTraitChange(traitType, e.target.value)}
                >
                  <option value="">All {traitType}</option>
                  {Array.from(traitCategories[traitType])
                    .sort()
                    .map((value) => (
                      <option key={value} value={value}>
                        {value}
                      </option>
                    ))}
                </select>
              </div>
            ))}
        </div>
      </div>

      {/* Stats */}
      <div className="stats-bar">
        <div className="stats-info">
          Showing <strong>{filteredNFTs.length}</strong> of <strong>{CONFIG.TOTAL_SUPPLY}</strong> Dead Bears
        </div>
        <button className="clear-filters" onClick={clearFilters}>
          Clear All Filters
        </button>
      </div>

      {/* NFT Grid */}
      {filteredNFTs.length === 0 ? (
        <div className="empty-state">
          <h2>No Dead Bears Found</h2>
          <p>Try adjusting your filters to see more bears</p>
        </div>
      ) : (
        <div className="nft-grid">
          {filteredNFTs.map((nft) => (
            <NFTCard key={nft.edition} nft={nft} />
          ))}
        </div>
      )}
    </div>
  );
};

// NFT Card Component
const NFTCard: React.FC<{ nft: NFT }> = ({ nft }) => {
  const imageUrl = `${CONFIG.IMAGE_BASE_URL}${nft.edition}.png`;
  const traits = nft.attributes?.slice(0, 3) || [];

  return (
    <div className="nft-card" onClick={() => window.open(imageUrl, '_blank')}>
      <img src={imageUrl} alt={nft.name} className="nft-image" loading="lazy" />
      <div className="nft-info">
        {nft.isOneOfOne && <span className="one-of-one-badge">1/1 LEGENDARY</span>}
        <div className="nft-name">{nft.name}</div>
        <div className="nft-id">#{nft.edition}</div>
        <div className="nft-traits">
          {traits.map((trait, index) => (
            <span key={index} className="trait-tag">
              {trait.value}
            </span>
          ))}
        </div>
      </div>
    </div>
  );
};

export default Gallery;